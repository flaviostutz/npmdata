/* eslint-disable functional/immutable-data */
/* eslint-disable no-restricted-syntax */
import fs from 'node:fs';
import path from 'node:path';

import { readJsonFile, writeJsonFile, parsePackageSpec } from './utils';
import { PublishablePackageJson } from './types';

/**
 * Read the version of the currently running npmdata package so we can pin it
 * in the generated package.json rather than using 'latest'.
 */
function getOwnVersion(): string {
  // eslint-disable-next-line functional/no-try-statements
  try {
    const ownPkg = readJsonFile<{ version: string }>(path.join(__dirname, '../package.json'));
    return `^${ownPkg.version}`;
  } catch {
    return 'latest';
  }
}

export type PublisherInitOptions = {
  /**
   * Working directory where to initialize (default: current working directory)
   */
  workingDir?: string;

  /**
   * Additional package specs to include as data sources alongside this package.
   * Each entry is a bare package name ("my-pkg") or a name with a semver constraint
   * ("my-pkg@^1.2.3"). They will be listed in package.json under `npmdata.additionalPackages`
   * and added to `dependencies`, so the generated CLI script will extract data from all of
   * them together with the data contained in the package being initialized.
   */
  additionalPackages?: string[];
};

export type InitResult = {
  success: boolean;
  message: string;
  publishedFolders?: string[];
  additionalPackages?: string[];
  packageJsonPath?: string;
};

/**
 * Parse a package spec like "pkg@^1.0.0" or "@scope/pkg@2.x" into name and version.
 * Delegates to the shared utility; keeps 'latest' as default when no version is given.
 */
function parsePublisherPackageSpec(spec: string): { name: string; version: string } {
  const { name, version } = parsePackageSpec(spec);
  return { name, version: version ?? 'latest' };
}

function validateFolders(
  folders: string[],
  workingDir: string,
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  for (const folder of folders) {
    const folderPath = path.join(workingDir, folder);
    if (!fs.existsSync(folderPath)) {
      errors.push(`Folder not found: ${folder}`);
    } else if (!fs.statSync(folderPath).isDirectory()) {
      errors.push(`Not a directory: ${folder}`);
    }
  }

  return { valid: errors.length === 0, errors };
}

function generateCliScript(): string {
  return `#!/usr/bin/env node

// DON'T EDIT THIS FILE MANUALLY - this script is generated by "npmdata init" command
require('npmdata/dist/runner.js').run(__dirname);
`;
}

function preparePackageJson(
  folders: string[],
  workingDir: string,
  additionalPackages: string[] = [],
): PublishablePackageJson {
  const packageJsonPath = path.join(workingDir, 'package.json');

  // eslint-disable-next-line functional/no-let
  let packageJson: PublishablePackageJson;

  if (fs.existsSync(packageJsonPath)) {
    packageJson = readJsonFile<PublishablePackageJson>(packageJsonPath);
  } else {
    packageJson = {
      name: path.basename(workingDir),
      version: '1.0.0',
    };
  }

  if (!packageJson.name) packageJson.name = path.basename(workingDir);
  if (!packageJson.version) packageJson.version = '1.0.0';

  // eslint-disable-next-line unicorn/no-keyword-prefix
  const newFolderPatterns = folders.map((folder) => `${folder}/**`);
  const existingPatterns = (packageJson.files as string[]) ?? [];
  const existingFolderPatterns = existingPatterns.filter((p) => p.endsWith('/**'));
  const existingNonFolderPatterns = existingPatterns.filter((p) => !p.endsWith('/**'));

  packageJson.files = Array.from(
    new Set([
      // eslint-disable-next-line unicorn/no-keyword-prefix
      ...newFolderPatterns,
      ...existingFolderPatterns,
      ...existingNonFolderPatterns,
      'package.json',
      'bin/npmdata.js',
    ]),
  );

  if (!packageJson.dependencies) {
    packageJson.dependencies = {};
  }
  packageJson.dependencies.npmdata = getOwnVersion();

  // Merge additional packages: preserve existing entries, add new ones without duplicates
  const existingAdditional = packageJson.npmdata?.additionalPackages ?? [];
  const mergedAdditional = Array.from(new Set([...existingAdditional, ...additionalPackages]));

  // Store additional packages config and add them to dependencies
  if (mergedAdditional.length > 0) {
    packageJson.npmdata = { ...packageJson.npmdata, additionalPackages: mergedAdditional };
    for (const pkgSpec of mergedAdditional) {
      const { name: pkgName, version: pkgVersion } = parsePublisherPackageSpec(pkgSpec);
      if (!packageJson.dependencies[pkgName]) {
        packageJson.dependencies[pkgName] = pkgVersion;
      }
    }
  }

  if (!packageJson.bin) {
    packageJson.bin = 'bin/npmdata.js';
  }

  return packageJson;
}

/**
 * Initialize publisher configuration with specified folders
 */
export async function initPublisher(
  folders: string[],
  options: PublisherInitOptions = {},
): Promise<InitResult> {
  const workingDir = options.workingDir ?? process.cwd();
  const additionalPackages = options.additionalPackages ?? [];

  // eslint-disable-next-line functional/no-try-statements
  try {
    if (!folders || folders.length === 0) {
      return {
        success: false,
        message: 'npmdata: no folders specified. Usage: npmdata init <folder1> <folder2> ...',
      };
    }

    const validation = validateFolders(folders, workingDir);
    if (!validation.valid) {
      return {
        success: false,
        message: `npmdata: folder validation failed:\n${validation.errors.join('\n')}`,
      };
    }

    const packageJson = preparePackageJson(folders, workingDir, additionalPackages);
    const packageJsonPath = path.join(workingDir, 'package.json');
    writeJsonFile(packageJsonPath, packageJson);

    const cliScriptPath = path.join(workingDir, 'bin', 'npmdata.js');
    fs.mkdirSync(path.dirname(cliScriptPath), { recursive: true });
    fs.writeFileSync(cliScriptPath, generateCliScript(), 'utf8');
    fs.chmodSync(cliScriptPath, 0o755);

    const finalAdditionalPackages = packageJson.npmdata?.additionalPackages;

    return {
      success: true,
      message: 'npmdata: project initialization completed successfully',
      publishedFolders: folders,
      additionalPackages: finalAdditionalPackages,
      packageJsonPath,
    };
  } catch (error) {
    return {
      success: false,
      message: `npmdata: initialization failed: ${String(error)}`,
    };
  }
}
